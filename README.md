# Building a Trie in Python

The trie is a specialized type of tree structure. Here we build the Trie class based on the TrieNode class. The node has two attributes: 'is_word' to indicate if it's the end of a word, and 'children' to point to the next character. 

To search for a word or a prefix, the longest depth needed to search is just the length of the word or prefix. If L is the length of the word/prefix, the time complexity will be O(L), because worst case senario, each node has 26 children (26 characters), total comparison steps are 26L. If we compare this with the input size, which should be the size of the Trie itself, then it's O(1), because it's independent of the Trie size. Space complexity is O(1) too. 

For the finding suffix part it's a bit complex. Because there are three type of words here, 1) a short word whose extension could be another word, such as 'fun', the is_word feature will be true but it does still have children, for example 'function'; 2) long word such as 'function' which contains a shorter word; 3) regular word without these problems. We can save a lot of space in a Trie partially because many words share some common parts, such as 'fun' and 'function'. These actually cause some difficulty for me to implement the suffix functionality. I use two diffenrent helper functions to deal with class 1) and class 2) & 3) situations respectively. I use recursion to go down the branches of the tree to gather and put together the charaters downstream a given node. Because I need to traverse through all nodes downstream of that node (worst case if the input node is the root then I need to reach all nodes of this Trie), the time complexity is O(n), where n is the input size, namely the total number of nodes in the Trie. Space complexity is O(n).

